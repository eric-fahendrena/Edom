{"version":3,"names":["global","factory"],"sources":["src/edom.js"],"sourcesContent":["(function(global, factory) {\n\n   // Load the factory into the right environment\n   if (typeof module === \"object\" && typeof module.exports === \"object\") {\n      module.exports = factory(global, true);\n   } else {\n      factory(global);\n   }\n\n})(typeof window !== \"undefined\" ? window : this, function(window, noGlobal) {\n\n   const edom = {\n\n      /**\n       * Create new html element(s)\n       * @param   {string | Array<string>} elName - Single element name or array of element names\n       * @return  {HTMLElement | Array<HTMLElement>} - Single HTMLElement or array of HTMLElements\n       */\n      create: elName => {\n         if (Array.isArray(elName)) {\n            return elName.map(name => document.createElement(name));\n         } else {\n            return document.createElement(elName);\n         }\n      },\n\n      /**\n       * Find an element by id\n       * @param   {String} id element id (without #)\n       * @return   {HTMLElement} the element with the given id\n       */\n      find: id => document.getElementById(id),\n\n      /**\n       * Select an element from html\n       * @param   {String} query selector\n       * @return   {HTMLElement} an element selected\n       */\n      select: qs => document.querySelector(qs),\n\n      /**\n       * Select all elements having the specified query selector\n       * @param   {String} query selector\n       * @param   {Array.<HTMLElement>} elements selected and each item is of type object\n       */\n      selectAll: qs => document.querySelectorAll(qs),\n\n      /**\n       * Apply the attributes specified in params, as an Object, to a HTMLElement.\n       * @param   {HTMLElement} element\n       * @return   {Function(attrsObj<Object>)} apply the attrs to the element\n       */\n      addAttr: el => attrsObj => {\n         const attrsArrayed = Object.entries(attrsObj);\n         attrsArrayed.forEach(arr => el.setAttribute(arr[0], arr[1]));\n      },\n\n      /**\n       * add CSS to an element\n       * @param   {HTMLElement}\n       * @return   {Function(styleObj<Object>)}\n       */\n      addCSS: el => style => {\n         const styleArrayed = Object.entries(style);\n         styleArrayed.forEach(arr => el['style'][arr[0]] = arr[1]);\n      },\n\n      /**\n       * Get style of an element. Note that it only return the style set from javascript and not the computed style.\n       * @param   {HTMLElement} element\n       * @return   {Function(cssProp<String>)} specify the css property to get\n       */\n      getCSS: element => cssProp => {\n         return element['style'][cssProp];\n      },\n\n      /**\n       * Get computed style of an HTMLElement\n       * @param   {HTMLElement} element\n       */\n      getComputedCSS: element => cssProp => {\n         const compStyle = window.getComputedStyle(element);\n         return compStyle.getPropertyValue(cssProp);\n      },\n\n      /**\n       * Add class\n       * @param   {HTMLElement}\n       * @return   {Function(className<Array|String>)}\n       */\n      addClass: element => classNames => {\n         if (Array.isArray(classNames)) {\n            classNames.forEach(item => element.classList.add(item));\n         } else {\n            element.classList.add(classNames);\n         }\n      },\n\n      /**\n       * Remove class\n       * @param   {HTMLElement}\n       * @return   {Function(className<Array|String>)}\n       */\n      removeClass: element => classNames => {\n         if (Array.isArray(classNames)) {\n            classNames.forEach(item => element.classList.remove(item));\n         } else {\n            element.classList.remove(classNames);\n         }\n      },\n\n      /**\n       * Toggle class\n       * @param   {HTMLElement}\n       * @return   {Function(className<String>)}\n       */\n      toggleClass: element => className => {\n         element.classList.toggle(className);\n      },\n\n      /**\n       * Verify if an element contain a class.\n       * @param   {HTMLElement}\n       * @return   {Function(className<String>): boolean}\n       */\n      containsClass: element => className => {\n         return element.classList.contains(className);\n      },\n\n      /**\n       * Set inner text of HTMLElement(s).\n       * @param   {HTMLElement | Array<HTMLElement>} el - Single HTMLElement or array of HTMLElements\n       * @return  {Function(text<String>)}\n       */\n      write: el => text => {\n         if (Array.isArray(el)) {\n            el.forEach((element) => {\n               element.innerText = text;\n            });\n         } else {\n            el.innerText = text;\n         }\n      },\n\n      /**\n       * Set html code\n       * @param   {HTMLElement} element\n       * @return   {Function(htmlCode<String>)} add the html code into the element\n       */\n      setHTML: el => htmlCode => el['innerHTML'] = htmlCode,\n\n      /**\n       * add html code\n       * @param   {HTMLElement} element\n       * @return   {Function(htmlCode<String>)} add the html code into the element\n       */\n      addHTML: el => htmlCode => el['innerHTML'] += htmlCode,\n\n      /**\n       * Append a HTMLElement in an HTMLElement as child.\n       * @param   {HTMLElement  | Array<HTMLElement>} child\n       * @return   {Function(child<HTMLElement>)} specify the parent\n       */\n      append: child => parent => {\n         if (Array.isArray(child)) {\n            parent.appendChild(child[0]);\n            let ref = child[0];\n            for (let i = 1; i < child.length; i++) {\n               ref.after(child[i]);\n               ref = child[i];\n            }\n         } else {\n            parent.appendChild(child);\n         }\n      },\n\n      /**\n       * Rotate an element.\n       * @param   {HTMLElement} element\n       * @return   {Function(degrees<Integer>)} specify the degrees to apply.\n       */\n      rotate: element => degrees => {\n         edom.addCSS(element)({ transform: `rotate(${degrees}deg)` });\n      },\n\n      /**\n       * Dynamic script loading\n       * @param   {String} src\n       */\n      loadScript: (src) => {\n         const script = edom.create('script');\n         edom.addAttr(script)({ src });\n         edom.append(script)(document.body);\n      },\n\n      /**\n       * Add event listener to an element\n       * @param   {string | HTMLElement} element\n       * @return   {Function(event<String>): handler<Function>} specify the event type and the handler\n       */\n      addEvent: element => event => handler => {\n         if (typeof element == 'string') {\n            edom.select(element).addEventListener(event, handler)\n         } else {\n            element.addEventListener(event, handler);\n         }\n      },\n\n      /**\n       * Remove event listener from an element\n       * @param   {string | HTMLElement} element\n       * @return   {Function(event<String>): handler<Function>} specify the event type and the handler\n       */\n      removeEvent: element => event => handler => {\n         if (typeof element == 'string') {\n            edom.select(element).removeEventListener(event, handler)\n         } else {\n            element.removeEventListener(event, handler);\n         }\n      },\n\n      /**\n       * Insert an element before another element\n       * @param {HTMLElement} referenceElement The reference element before which the new element will be inserted\n       * @return {Function(newElement<HTMLElement>)} - newElement - The new element to be inserted\n       */\n      insertBefore: referenceElement => newElement => {\n         referenceElement.parentNode.insertBefore(newElement, referenceElement);\n      },\n\n      /**\n       * Insert an element after another element\n       * @param {HTMLElement} The reference element after which the new element will be inserted\n       * @return {Function(referenceElement<HTMLElement>)} - newElement - The new element to be inserted\n       */\n      insertAfter: referenceElement => newElement => {\n         referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);\n      },\n\n      /**\n       * Apply CSS animation to an element\n       * @param {HTMLElement} element - The element to animate\n       * @return {Function(animObject<object>)} - Apply animation\n       */\n      applyAnimation: element => animObject => {\n         edom.addCSS(element)({\n            animationName: animObject.name,\n            animationDuration: animObject.duration,\n            animationTimingFunction: animObject.timingFunction,\n         });\n      },\n\n      /**\n       * Perform an AJAX GET request\n       * @param {String} url - The URL to send the request to\n       * @param {Function(callback)} callback - The callback function to handle the response\n       */\n      ajaxGet: url => callback => {\n         const xhr = new XMLHttpRequest();\n         xhr.open('GET', url, true);\n         xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4 && xhr.status === 200) {\n               callback(xhr.responseText);\n            }\n         };\n         xhr.send();\n      },\n\n      /**\n       * Perform a Fetch GET request\n       * @param {String} url - The URL to send the request to\n       * @return {Promise} - A promise that resolves to the response\n       */\n      fetchGet: url => {\n         return fetch(url)\n            .then(response => response.json())\n            .catch(error => console.error('Error:', error));\n      },\n\n      /**\n       * Serialize form data\n       * @param {HTMLFormElement} form - The form element to serialize\n       * @return {Object} - The serialized form data\n       */\n      serializeForm: form => {\n         const formData = new FormData(form);\n         const data = {};\n         formData.forEach((value, key) => {\n            data[key] = value;\n         });\n         return data;\n      },\n\n      /**\n       * Multiply an element by creating the specified number of copies and inserting them after the element.\n       * @param   {HTMLElement} element\n       * @return   {Function(number<Number>)} specify the number of copies\n       */\n      multiply: element => number => {\n         let referenceNode = element;\n         for (let i = 0; i < number; i++) {\n            const clone = element.cloneNode(true);\n            referenceNode.after(clone);\n            referenceNode = clone;\n         }\n      },\n   };\n\n   if (!noGlobal) {\n      window.edom = edom;\n   }\n\n   return edom;\n\n});\n"],"mappings":"UAAUA,EAGeC,G","ignoreList":[]}